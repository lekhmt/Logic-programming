# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Леухин М.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В языке Пролог списками являются объекты, которые содержат в себе определённое число других объектов.
Их можно сравнить с массивами в императивных языках - только  
в отличие от императивных языков не нужно заранее указывать размерность. Помимо этого, 
в списках в языке Пролог могут храниться объекты разных типов данных.
Более верным будет сравнение с односвязными списками в императивных языках -
мы не имеем произвольного доступа к любому элементу, в отличие от массивов. Для доступа к элементу под
номером *n* нужно перебрать предыдущие *n - 1* элементов.

## Задание 1.1: Предикат обработки списка

 `delete_t(X, Y, Z)` - удаляет из списка Y все элементы со значением X и сохраняет полученный список в Z.
Предикат написан без использования встроенных предикатов.


Примеры использования:
```prolog
?- delete_t(1, [0, 1, 2, 1, 0, 2, 2, 1, 0], L), write(L).
[0,2,0,2,2,0]
?- delete_t(L, [0, 1, 2, 1, 0, 2, 2, 1, 0], [0, 2, 0, 2, 2, 0]), write(L).
1
```

Реализация:
```prolog
delete_t(_, [], []).
delete_t(X, [X|T], L) :- delete_t(X, T, L).
delete_t(X, [Y|T], [Y|T1]) :- delete_t(X, T, T1).
```

Предикат задаётся рекурсивно. На каждой итерации возможны 3 ситуации: 
* `delete_t(_, [], []).` При удалении любого элемента из пустого списка получаем пустой список.
* `delete_t(X, [X|T], L). :- delete_t(X, T, L).` При удалении элемента `X` из списка `[X|T]`
(то есть элемент `X` является головой рассматриваемого списка) получаем список `T`, который,
однако, может содержать другие элементы со значением `X`, а потому нужно продолжить выполнение 
предиката уже для списка `T`.
* `delete_t(X, [Y|T], [Y|T1]) :- delete_t(X, T, T1).` При удалении элемента `X` из списка
`[Y|T]` (`X` не является головой списка) получаем список `[Y|T1]`, где `T1` - хвост `T`
списка `[Y|T]`, для которого выполнена операция удаления всех элементов со значением `X`.

`delete_s(X, Y, Z)` - удаляет из списка Y все элементы со значением X и сохраняет полученный список в Z.
Предикат написан с использованием встроенных предикатов.
Примеры использования:
```prolog
?- delete_s(5, [1, 5, 2, 5], R).
R = [1, 2].
?- delete_s(X, [1, 5, 2, 5], [1, 2]).
X = 5.
```
Реализация:
```prolog
delete_s(X, L, L) :- not(member(X, L)).
delete_s(X, L, R) :- member(X, L), remove_t(X, L, NEW_L), delete_s(X, NEW_L, R), !.
```
Пока в списке `L` есть элемент `X`, удаляем одно такое вхождение и рекусривно вызываем предикат для оставшегося списка.

## Задание 1.2: Предикат обработки числового списка

`merge_t(L, R, M)` - сливает упорядоченные списки `L` и `R` в список `M`.


Примеры использования:
```prolog
?- merge_t([1, 3], [2, 4], L), write(L).
[1,2,3,4]
?- merge_t([1, 3], L, [1, 2, 3, 4]), write(L).
[2,4]
```

Реализация:
```prolog
merge_t([], X, X).
merge_t(X, [], X).
merge_t([L|LS], [R|RS], [L|M]) :- merge_t(LS, [R|RS], M), L < R.
merge_t([L|LS], [R|RS], [R|M]) :- merge_t([L|LS], RS, M), R =< L.
```

Предикат задаётся рекурсивно. На каждой итерации возможны 3 ситуации:
* `merge_t([], X, X).` или `merge_t(X, [], X).` В случае слияния пустого списка со списком `X` получаем 
список `X`.
* `merge_t([L|LS], [R|RS], [L|M]) :- merge_t(LS, [R|RS], M), L < R.` В случае, если значение головы `L` списка
`[L|LS]` меньше значения головы `R` списка `[R|RS]`, мы должны получить список `[L|M]`, где `M` - список,
полученный слиянием списков `LS` и `[R|RS]`. Важно: при выполнении предиката сначала выполняется предикат
`merge_t(LS, [R|RS], M)` и лишь после проверка `L < R`. В ином случае (если сначала выполнять проверку) 
невозможно будет выолнить обратную операцию - определить, с каким списком `R` нужно слить список `L`, чтобы
получить список `M`.
* `merge_t([L|LS], [R|RS], [R|M]) :- merge_t([L|LS], RS, M), R =< L.` В случае, если значение головы `L` списка
  `[L|LS]` больше или равно значению головы `R` списка `[R|RS]`, мы должны получить список `[R|M]`, где `M` - список,
  полученный слиянием списков `RS` и `[L|LS]`. 

## Пример использования предикатов

`minus(L1, L2, R)` - алгебраическая разность множеств, представленных упорядоченными списками `L1` и `L2`.

Примеры использования: 

```prolog
?- minus([1, 2, 3, 4], [2, 4], R).
R = [1, 3] .
?- minus([2, 4], [1, 2, 3, 4], R).
R = [] .
```

Реализация:
```prolog
minus(L, [], L).
minus(L, [H|T], RS) :- merge_t(L, [H|T], P), delete_t(H, P, R), minus(R, T, RS).
```

С помощью предиката слияния `merge` получаем общий список элементов двух списков, из которого удаляем все вхождения элемента 
`H` второго списка, после чего рекурсивно вызываем предикат для оставшихся элементов второго списка. 

## Задание 2: Реляционное представление данных

Реляционные базы данных представляют собой базы данных, которые используются для хранения и предоставления
доступа к взаимосвязанным элементам информации. Реляционные базы данных основаны на реляционной модели - 
интуитивно понятном, наглядном табличном способе представления данных. Каждая строка, содержащая в 
таблице такой базы данных, представляет собой запись с уникальным идентификатором, который называют
ключом. Столбцы таблицы имеют атрибуты данных, а каждая запись обычно содержит значение для каждого
атрибута, что дает возможность легко устанавливать взаимосвязь между элементами данных.

Поэтому основными плюсами реляционного представления данных будут простота и доступность для понимания людьми.
Однако за это придётся заплатить снижением скорости работы и увеличением объёма памяти для хранения таблицы.

В моём варианте используется представление в виде, описанном в файле `four.pl`, то есть на основе предикатов
`group(номер, список студентов)` и `subject(название предмета, список оценок)`, где список оценок представлен 
в виде предикатов `grade(студент, оценка)`. Для выполнения задания использовались следующие предикаты:
1. `sum(L, S)` - для числовых списокв в переменную `S` записывается сумма всех элементов списка `L`.
2. `merge(L, S)` - предикат для обработки списков, элементами которых будут другие списки. Возвращает единый список всех
элементов списков. 
3. `average(M, N, G)` - записывает в переменную `N` средний балл по всем экзаменам для ученика `M`.
4. `do_all_average(L)` - вызывает предикат `average` для всех элементов из списка `L` и обрабатывает полученный результат.
5. `find_fails_for_subject(S, N)` - находит количество студентов, несдавших экзамен по предмету `S`.
6. `do_all_fails(L)` - вызывает предикат `find_fails_for_subject` для каджого предмета и обрабатывает полученный результат.
7. `refactor(L, S)` - принимает на вход список студентов и возвращает список с элементами вида `[студент, средний балл]`.
8. `max(L, R, O)` - находит максимум из двух чисел.
9. `findmax(L, M)` - находит максимальный средний балл для списка студентов `L`.
10. `do_average_group(L)` - вызывает предикат `findmax` для каждой группы и обрабатывает полученный результат.

## Выводы

В ходе лабораторной работы мною было изучено представление списков в языке Prolog, а также я узнал какие есть стандартные
предикаты для обработки списков и более того - научился их реализовывать самостоятельно.

Также я узнал о реляционном способе представления данных и научился работать с таким представлением - анализировать его,
составлять предикаты для обработки информации, представленной в таком виде.

Из этой лабораторной работы я вынес для себя важную мысль - полезно разбивать функционал предикатов на несколько, чтобы 
в будушем повторно их использовать, чем вешать всю работу на один предикат. К тому же, это значительно упрощает отладку 
программы.

