#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Леухин М.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Сущесвтует два подхода к решению логических задач:
* Установление соответствия - в таких задачах даётся набор фактов, которые нужно связать между собой, чтобы найти решения.
* Метод генерации гипотезы - заключается в переборе всех возможных решений и их проверке на соответствие 
правилам задачи.

Для решения логических задач удобно использовать язык Prolog, так как он предоставляет инструменты для удобного
описания фактов, приведённых в задаче, а также позволяет легко организовать перебор решений.

## Задание

11. 6 человек назовем их А, Б, В, Г, Д и Е кандидаты посты председателя, заместителя председателя 
и секретаря правления общества любителей логических задач. Но определить состав этой тройки оказалось
не так-то легко. Судите сами: А не хочет входить в состав руководства, если Д не будет председателем. 
Б не хочет входить в состав руководства, если ему придется быть старшим над В. Б не хочет работать 
вместе с Е ни при каких условиях. В не хочет работать, если в состав руководства войдут Д и Е вместе.
В не будет работать, если Е будет председателем, или если Б будет секретарем. Г не будет работать с 
В или Д, если ему придется подчиняться тому или другому. Д не хочет быть заместителем председателя. 
Д не хочет быть секретарем, если в состав руководства войдет Г. Д не хочет работать вместе с А, если 
Е не войдет в состав руководства. Е согласен работать только в том случае, если председателем будет 
либо он, либо В. Как они решили эту проблему? .

## Принцип решения

По условию задачи у нас есть 6 человек, которые претендуют на полуяение 3 должностей. Для удобства 
добавим помимо должностей "председатель", "заместитель председателя" и "секретарь" 
3 своеобразных должности "безработный" - в таком случае будет удобно сопоставлять 6 человек и 6 должностей.

Для получения решения задания используется предикат `solve`, который с использованием предиката `setof` получает 
список всех решений (на самом деле там будет лишь одно решение, просто оно будет повторяться несколько раз - 
именно поэтому и используется предикат `setof`, результатом работы которого будет список уникальных решений):

```prolog
% получаем все различные решения и выводим их
solve() :-
    setof([A,B,V,G,D,E], all_conditions([A,B,V,G,D,E]), [[X,Y,Z,O,P,U]]),
    write("A: "), write(X), nl,
    write("Б: "), write(Y), nl,
    write("В: "), write(Z), nl,
    write("Г: "), write(O), nl,
    write("Д: "), write(P), nl,
    write("Е: "), write(U), nl.
```

Для получения очередного решения используется вспомогательный предикат `all_conditions`, который с помощью
предиката `permutation` получает очередную перестановку должностей и проверяет, подходит ли она под условия:
```prolog
% проверяем очередное рещение на соблюдение всех условий
all_conditions([A,B,V,G,D,E]) :-
    POSITIONS = ["председатель", "заместитель", "секретарь", "безработный", "безработный", "безработный"],
    permutation([A,B,V,G,D,E], POSITIONS),
    condition1(A,B,V,G,D,E),
    condition2(A,B,V,G,D,E),
    condition3(A,B,V,G,D,E),
    condition4(A,B,V,G,D,E),
    condition5(A,B,V,G,D,E),
    condition6(A,B,V,G,D,E),
    condition7(A,B,V,G,D,E),
    condition8(A,B,V,G,D,E),
    condition9(A,B,V,G,D,E),
    condition10(A,B,V,G,D,E).
```    
Предикаты `condition` отражают условия, описываемые в задании. Если условие не выпонляется, предикат 
возвращает `fail`:
```prolog
% А не хочет входить в состав руководства, если Д не будет председателем.
condition1(A,_,_,_,D,_) :- D \= "председатель", A \= "безработный", !, fail.
condition1(_,_,_,_,_,_).

% Б не хочет входить в состав руководства, если ему придется быть старшим над В.
condition2(_,B,V,_,_,_) :- B == "председатель", V == "заместитель", !, fail.
condition2(_,B,V,_,_,_) :- B == "председатель", V == "секретарь", !, fail.
condition2(_,B,V,_,_,_) :- B == "заместитель", V == "секретарь", !, fail.
condition2(_,_,_,_,_,_).

% Б не хочет работать вместе с Е ни при каких условиях.
condition3(_,B,_,_,_,E) :- E \= "безработный", B \= "безработный", !, fail.
condition3(_,_,_,_,_,_).

% В не хочет работать, если в состав руководства войдут Д и Е вместе.
condition4(_,_,V,_,D,E) :- D \= "безработный", E \= "безработный", V \= "безработный", !, fail.
condition4(_,_,_,_,_,_).

% В не будет работать, если Е будет председателем, или если Б будет секретарем.
condition5(_,_,V,_,_,E) :- E == "председатель", V \= "безработный", !, fail.
condition5(_,B,V,_,_,_) :- B == "секретарь", V \= "безработный", !, fail.
condition5(_,_,_,_,_,_).

% Г не будет работать с В или Д, если ему придется подчиняться тому или другому.
condition6(_,_,V,G,_,_) :- V == "председатель", G == "заместитель", !, fail.
condition6(_,_,V,G,_,_) :- V == "председатель", G == "секретарь", !, fail.
condition6(_,_,V,G,_,_) :- V == "заместитель", G == "секретарь", !, fail.
condition6(_,_,_,G,D,_) :- D == "председатель", G == "заместитель", !, fail.
condition6(_,_,_,G,D,_) :- D == "председатель", G == "секретарь", !, fail.
condition6(_,_,_,G,D,_) :- D == "заместитель", G == "секретарь", !, fail.
condition6(_,_,_,_,_,_).

% Д не хочет быть заместителем председателя.
condition7(_,_,_,_,D,_) :- D == "заместитель", !, fail.
condition7(_,_,_,_,_,_).

% Д не хочет быть секретарем, если в состав руководства войдет Г.
condition8(_,_,_,G,D,_) :- G == "председатель", D == "секретарь", !, fail.
condition8(_,_,_,G,D,_) :- G == "заместитель", D == "секретарь", !, fail.
condition8(_,_,_,_,_,_).

% Д не хочет работать вместе с А, если Е не войдет в состав руководства.
condition9(A,_,_,_,D,E) :- D \= "безработный", A \= "безработный", E == "безработный", !, fail.
condition9(_,_,_,_,_,_).

% Е согласен работать только в том случае, если председателем будет либо он, либо В.
condition10(_,_,V,_,_,E) :- E == "заместитель", V \= "председатель", !, fail.
condition10(_,_,V,_,_,E) :- E == "секретарь", V \= "председатель", !, fail.
condition10(_,_,_,_,_,_).
```

Результат работы предиката `solve`:
```prolog
A: безработный
Б: заместитель
В: председатель
Г: безработный
Д: секретарь
Е: безработный
```

## Выводы

В ходе выполнения лабораторной работы я изучил основные методы решения логических задач на языке Prolog и
написал программу для решения такой задачи. Проанализируем слонжность, эффективность, безопасность и непротиворечивость 
полученного решения:
* Сложность, эффективность и безопасность: так как для решения задачи испоьлзуется перебор всех вариантов, эффективнее факториальной сложности
`O(n!)` алгоритма не придумать. Однако без улучшения алогритмической сложности мы всё равно можем добиться
улучшения эффективности программы с помощью отсечения. Благодаря отсечению мы не обрабатываем те решения, 
которые заранее будут неверными. Этот же оператор обеспечивает безопасность решения - благодаря отсечению мы
не можем нигде получить бесконечные циклы в виде зацикливающихся ветвей.
* Непротиворечивость: программа выводит лишь одно решение, которое явно удовлетворяет всем условиям.
Стоит отметить, что это одно решение именно с точки зрения задачи - если бы мы использовали `findall` вместо
`setof` мы бы получили 6 решений засчёт того, что 3 должности "безработный" одинаковы именно для нас, а с точки
зрения Prolog эти должности образуют 6 различных перестановок.



