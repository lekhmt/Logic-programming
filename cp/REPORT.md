# Отчет по курсовому проекту

## по курсу "Логическое программирование"

### студент: Леухин Матвей Викторович

## Результат проверки

Вариант задания:

- [ ] стандартный, без NLP (на 3)
- [x] стандартный, с NLP (на 3-4)
- [ ] продвинутый (на 3-5)

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Данная курсовая работа будет полезной для меня по той причине, что заставит меня взглянуть на подход
к программированию под другим углом. Парадигма логического программирования является новой для меня, а потому
выглядит довольно загадочно и интересно. Меня привлекает возможность попробовать новые инструменты для решения
задачи. К тому же особый интерес для меня представляет задание, в котором
нужно реализовать естественно-языковой интерфейс, так как до прохождения курса логического программирования 
я не имел абсолютно никаких представлений о том, как можно подойти к решению такого рода задач. 

## Задание

1. Создать родословное дерево своего рода на несколько поколений назад в стандартном формате GEDCOM.
2. Преобразовать файл формата GEDCOM в набор утверждений на языке Prolog с использованием предиката
   `parent(родитель, ребёнок)`, `sex(человек, m/f)`.
3. Реализовать предикат проверки/поиска двоюродного брата.
4. Реализовать программу на языке Prolog, которая позволит определить степень родства двух произвольных индивидуумов в
   дереве.
5. Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и
   получать осмысленные ответы.

## Получение родословного дерева

Для составления родословного дерева был использован сервис MyHeritage.com. После привлечения семейных ресурсов удалось
составить родословное дерево глубиной в 5 поколений и содержащее 33 персоны.

## Конвертация родословного дерева

Для конвертации родословного дерева в набор утверждений на языке Prolog мною было принято решение использовать
интерпретируемый язык Python. Данный язык позволяет с легкостью писать простые скрипты без использования излишних
ресурсов, а также не требует больших затрат времени и сил для изучения.

Принцип действия программы основывается на структуре файла GEDCOM, который состоит из своеобразных блоков. Каждая строка
начинается с числа, которое означает уровень вложенности данного блока. Особый интерес представляют следующие
структурные части файла GEDCOM:

1. Блоки с информацией о персоне, содержащие его идентификатор, имя, пол и информацию о том, к каким семьям он
   относится.
2. Блоки с информацией о семьях, в которых описываются родственные связи между персонами.

Для получения нужного представления было принято решение обработать файл GEDCOM так, чтобы на выходе получить два
словаря:

1. Словарь `persons` с элементами вида `{идентификатор}: [имя, пол]`.
2. Словарь `parents` с элементами вида `{имя родителя}: [имя ребёнка, ...]`

На основе таких словарей далее можно с лёгкостью составить необходимые утверждения на языке Prolog.

Для заполнения словаря `persons` мы обрабатываем первую структурную часть файла GEDCOM, содержащую информацию о
персонах. Для этого мы считываем каждую строку файла и проверяем её на соответствие 2 критериям: она должны начинаться с
0 и содержать подстроку "INDI". Если это так, то мы встретили начало блока информации об очередной персоне. Из него нам
надо получить следующие параметры:

1. Идентификатор персоны.
2. Имя персоны.
3. Пол персоны.

После необходимо перейти к следующему блоку. Код, выполняющий обработку одного блока информации о персоне:

```python
if source[current][0] == '0' and source[current].find("INDI") != -1:
    uid = source[current][source[current].find("@") + 2:source[current].rfind("@")]
    current += 1
    while source[current][0] == '1' and source[current].find("NAME") == -1:
        current += 1
    name = source[current][7:].replace("/", "").replace("\n", "")
    current += 1
    while source[current][0] == '2':
        current += 1
    sex = source[current][-2]
    persons[uid] = [name, sex]
    while source[current][0] == '1':
        current += 1
    current -= 1
```

Для заполнения словаря `parents` мы обрабатываем вторую структурную часть файла GEDCOM, содержащую информацию о семьях.
Здесь в блоках информации нас интересуют лишь записи о родителях и детях. Для каждого из родителей мы заводим массив,
куда добавляем имена их детей. Хранить этот массив можно сразу в словаре, так как один и тот же человек может состоять в
разных семьях и иметь детей от разных браков, а соответственно информация о его детях будет расположена в разных блоках
в исходном файле. Код, выполняющий обработку одного блока информации о семье:

```python
if source[current][0] == '0' and source[current].find("FAM") != -1:
    current += 2
    father_uid = source[current][source[current].find("@") + 2:source[current].rfind("@")]
    current += 1
    mother_uid = source[current][source[current].find("@") + 2:source[current].rfind("@")]
    current += 1
    if parents.get(persons[father_uid][0]) is None:
        parents[persons[father_uid][0]] = []
    if parents.get(persons[mother_uid][0]) is None:
        parents[persons[mother_uid][0]] = []
    while source[current][0] == '1':
        if source[current].find("CHIL") != -1:
            child_uid = source[current][source[current].find("@") + 2:source[current].rfind("@")]
            parents[persons[father_uid][0]].append(persons[child_uid][0])
            parents[persons[mother_uid][0]].append(persons[child_uid][0])
        current += 1
    current -= 1
```

Примечание: так как для 5 задания удобно будет разбирать запросы на английском языке, а родословное дерево составлено на
русском, при парсинге дополнительно происходит транслитерация имён на английский язык.

После использования реализованной программы обработки файла `tree.ged` был получен файл `data.pl` со следующим
содержанием (для улучшения читаемости отчёта содержимое файла привожу лишь частично):

```prolog
sex("Matvej Leuhin", "M").
sex("Viktor Leuhin", "M").
sex("Irina Kovalevich", "F").
...
sex("Denis Kadnikov", "M").
sex("Larisa Petrova", "F").
sex("Anton Kovalevich", "M").

parent("Viktor Leuhin", "Matvej Leuhin").
parent("Irina Kovalevich", "Matvej Leuhin").
parent("Nikolaj Kovalevich", "Sergej Kovalevich").
...
parent("Tat'jana V'junova", "Denis Kadnikov").
parent("Aleksandr Kovalevich", "Anton Kovalevich").
parent("Larisa Petrova", "Anton Kovalevich").

```

## Предикат поиска родственника

Следующий предикат определяет двоюродного брата персоны `X` и помещает результат в переменную `M`:

```prolog
cousin_t(X, M) :- parent(P, X), parent(P1, P), parent(P1, O), P \= O, parent(O, M), sex(M, "M").
```

Принцип работы предиката крайне прост: для нахождения двоюродного брата персоны X необходимо последовательно найти:

1. Родителя `P` персоны `X`.
2. Родителя `P1` персоны `P`, то есть бабушку/дедушку `P1` персоны `X`.
3. Ребёнка `O` персоны `P1`, то есть тётю/дядю `O` персоны `X` (здесь нужно проверить, чтобы персона `O` и персона `P`
   не были одним и тем же человеком, иначе результатом выполнения предиката будет либо сама персона `X`, либо родные
   брат или сестра персоны `X`).
4. Найти ребёнка `M` персоны `O`, то есть двоюродного брата или двоюродную сестру `M` персоны `X`. Наконец, так как нас
   интересует именно двоюродный брат, необходимо проверить пол найденной персоны.

Таким образом результатом работы предиката будет только одна персона `M`, являющаяся двоюродным братом персоны `X`.
Обратно можно найти и информацию о том, для какой персоны `X` данная персона `M` является двоюродным братом.

Примеры работы предиката:

```prolog
?- setof(M, cousin_t("Matvej Leuhin", M), L).
L = ["Anton Leuhin"].
?- setof(X, cousin_t(X, "Matvej Leuhin"), L).
L = ["Anton Leuhin", "Jana Kovalevich", "Valerija Leuhina"].
?- cousin_t("Jana Kovalevich", "Matvej Leuhin").
true 
?- cousin_t("Matvej Leuhin", "Jana Kovalevich").
false.
```

## Определение степени родства

Для определения степени родства будем использовать поиск в пространстве состояний. Построенное родословное дерево уже
представляет собой граф, состояниями в котором будут конкретные люди. Рёбрами в таком случае будут являться отношения "
ребёнок - родитель", потому что именно по такому принципу и строится родословное дерево. Использовать дерево именно в
таком виде будет очень неудобно, ведь наличие только связи "ребёнок - родитель"
приведёт к тому, что ответом будут длинные и неудобные цепочки "son of mother of father of ...". Например, забегая
вперёд, вот вывод такой программы для одного запроса:

```prolog
?- relative("Matvej Leuhin", "Denis Kadnikov").
son of daughter of daughter of father of father
```

Для улучшения ситуации можно реализовать дополнительные связи родства, например "брат - сестра", "меж - жена" и т.д:

```prolog
father(X, Y) :- sex(X, "M"), parent(X, Y).
mother(X, Y) :- sex(X, "F"), parent(X, Y).
son(X, Y) :- sex(X, "M"), parent(Y, X).
daughter(X, Y) :- sex(X, "F"), parent(Y, X).
brother(X, Y) :- sex(X, "M"), parent(Z, X), parent(Z, Y), X \= Y.
sister(X, Y) :- sex(X, "F"), parent(Z, X), parent(Z, Y), X \= Y.
husband(X, Y) :- sex(X, "M"), sex(Y, "F"), parent(X, Z), parent(Y, Z).
wife(X, Y) :- husband(Y, X).
uncle(X, Y) :- parent(Z, Y), brother(X, Z).
aunt(X, Y) :- parent(Z, Y), sister(X, Z).
grandfather(X, Y) :- sex(X, "M"), parent(X, Z), parent(Z, Y).
grandmother(X, Y) :- sex(X, "Y"), parent(X, Z), parent(Z, Y).
grandson(X, Y) :- sex(X, "M"), parent(Z, X), parent(Y, Z).
granddaughter(X, Y) :- sex(X, "F"), parent(Z, X), parent(Y, Z).
cousin(X, Y) :- uncle(Z, X), parent(Z, Y).
cousin(X, Y) :- aunt(Z, X), parent(Z, Y).
nephew(X, Y) :- sex(X, "M"), aunt(Y, X) ; uncle(Y, X).
niece(X, Y) :- sex(X, "F"), aunt(Y, X) ; uncle(Y, X).
```

При этом предикаты, обозначающие переходы между состояниями в графе будут выглядеть так:

```prolog
move(X, Y, father) :- father(X, Y).
move(X, Y, mother) :- mother(X, Y).
move(X, Y, son) :- son(X, Y).
move(X, Y, daughter) :- daughter(X, Y).
move(X, Y, brother) :- brother(X, Y).
move(X, Y, sister) :- sister(X, Y).
move(X, Y, husband) :- husband(X, Y).
move(X, Y, wife) :- wife(X, Y).
move(X, Y, uncle) :- uncle(X, Y).
move(X, Y, aunt) :- aunt(X, Y).
move(X, Y, grandfather) :- granddaughter(X, Y).
move(X, Y, granddaughter) :- granddaughter(X, Y).
move(X, Y, grandson) :- grandson(X, Y).
move(X, Y, granddaughter) :- granddaughter(X, Y).
move(X, Y, cousin) :- cousin(X, Y).
move(X, Y, nephew) :- nephew(X, Y).
move(X, Y, niece) :- niece(X, Y).
```

С такой системой отношений граф на самом деле уже не будет тем самым родословным деревом, однако результат выполнения
предиката родства теперь выглядит значительно лучше:

```prolog
relative("Matvej Leuhin", "Denis Kadnikov").
son of cousin
```

Теперь стоит описать сам алгоритм определений родства. Основная идея заключается в том, что если мы хотим найти, кем
персона `X` приходится персоне `Y`, мы находим путь в графе от `X` до `Y`. Для этого будем использоваться алгоритм
поиска в глубину с итеративным углублением, так как он позволяет эффективнее всего (по сравнению с алгоритмами поиска в
глубину или в ширину) находить кратчайший путь:

```prolog
prolong([X|T],[Y,X|T]) :-
    move(X,Y,_),
    not(member(Y,[X|T])).

search_id(Start,Finish,Path,DepthLimit) :-
    depth_id([Start],Finish,Path,DepthLimit).

depth_id([Finish|T],Finish,[Finish|T],0).
depth_id(Path,Finish,R,N) :-
    N>0,
    prolong(Path,NewPath),
    N1 is N-1,
    depth_id(NewPath,Finish,R,N1).
```

В результате поиска мы получим путь от `X` до `Y` (в силу реализации алгоритма он будет найден в обратном порядке). Для
получения ответа на вопрос сначала "перевернём" найденный путь, а после начнём его обрабатывать:

1. Если путь состоит всего из 2 человек, то, очевидно, ответом на вопрос будет лишь одно слово, обозначающее связь `X`
   с `Y`. Эту связь найдём с помощью предиката `move` (именно для этого в предикате `move` третий аргумент отведён
   именно для отношения родства).
2. Если путь состоит больше, чем из 2 человек, то нужно установить связь всех соседних элементов пути - то есть людей.
   Для этого возьмём первых двух людей и, аналогично 1 пункту, определим их связь. После рекурсивно вызываем предикат
   для оставшегося списка.

Реализация предиката `relative` в таком случае принимает следующий вид:

```prolog
for(A, A, _).
for(X, A, B) :- A < B, A1 is A + 1, for(X, A1, B).

relative(X, Y) :-
    for(Current, 1, 5),
    search_id(X, Y, Path, Current),
    reverse(Path, ReversedPath),
    print_answer(ReversedPath).

reverse([], []).
reverse([X], [X]).
reverse([X|T], R) :-
    reverse(T, RT),
    append(RT, [X], R).

print_answer([X, Y]) :- move(X, Y, R), !, write(R), nl.
print_answer([X, Y|T]) :- move(X, Y, R), !, write(R), write(' of '), print_answer([Y|T]).
```

Примеры работы реализованного предиката:

```prolog
?- relative("Matvej Leuhin", "Irina Kovalevich").
son
?- relative("Matvej Leuhin", "Sergej Kovalevich").
nephew
?- relative("Evgenija Leuhina", "Denis Kadnikov").
daughter of cousin of son of cousin
```

Примечание 1. Так как предикат находит кратчайший путь первым, но с помощью него можно перебирать и другие варианты.
Например:

```prolog
?- relative("Matvej Leuhin", "Jana Kovalevich").
cousin
true ;
son of aunt
true ;
grandson of grandfather
true ;
nephew of father
true ;
son of husband of aunt
true ;
son of sister of father
true ;
...
```

Таких отношений довольно много, и на самом деле они выводятся несколько раз (в отчёте я оставил только уникальные). Это
связано с тем, что для нахождения цепочки родственников используются предикаты, которые могут возвращать одно значение
через разных людей. Например, в примере выше ответ "cousin" будет выведен 4 раза, так как в двух разных местах будет
задействован предикат `parent`, который вернёт значение `true` для двух разных людей (родителей же будет 2). Итого
получаем 4 различных ветки в дереве решений для Prolog-а, которые, однако, нас приведут к одному и тому же ответу.

Примечание 2. Предикаты `husband` и `wife` не реализованы на все 100% честно - они будут работать только в том случае,
если у потенциальных мужа и жены есть хотя бы один ребёнок. Это связано с тем, что изначально вариант представления
родословного дерева основан лишь на предикатах `parent` и `sex`, на основе которых нельзя установить связь "муж - жена".
Потенциальным решением проблемы может стать введение "несуществующих детей", которые будут связывать мужа и жену.

## Естественно-языковый интерфейс

Чтобы сделать естественно-языковой интерфейс для программы, сначала надо установить грамматику нашего языка.
Для определения грамматики необходимо задать следующие 4 объекта: терминальный словарь, нетерминальный словарь,
начальный символ и множество правил переходов. Для реализации естественно-языкового интерфейса был выбран английский язык, 
так как для русского языка пришлось бы дополнительно обрабатывать падежи, что значительно усложняет обработку фраз.

Перейдём к определению вышеописанных объектов:
1. Терминальный словарь будет состоять из вопросительных слов, обозначения родственных связей и человеческих имён. Также
в него войдут такие элементы, как "'s", "for" и "and". Фактического ограничения на использование любых слов нет, но именно эти 
элементы будут составлять основную часть предложения и на их основе будет определяться значащая семантика. То есть терминальный словарь:
   ```
   VT = {вопросительные слова, родственные связи, имена, "'s", "for", "and"}
   ```
2. Нетерминальный словарь можно описать следующим образом:
   ```
   VN = {ЗАПРОС, ВОПРОСИТЕЛЬНОЕ СЛОВО, СЕМАНТИКА, РОДСТВЕННАЯ СВЯЗЬ, ИМЯ}
   ```
3. Начальным символом будет `ЗАПРОС`.
4. Наконец, опишем возможные переходы:
   ```
   ЗАПРОС -> ВОПРОСИТЕЛЬНОЕ СЛОВО + СЕМАНТИКА
   СЕМАНТИКА -> РОДСТВЕННАЯ СВЯЗЬ + ... + ИМЯ + ... ||
                ИМЯ + "'s" + ... + РОДСТВЕННАЯ СВЯЗЬ + ... ||
                РОДСТВЕННАЯ СВЯЗЬ + "for" + ... + ИМЯ + ... ||
                ИМЯ + ИМЯ + "'s" + ... + РОДСТВЕННАЯ СВЯЗЬ + ... ||
                ИМЯ + РОДСТВЕННАЯ СВЯЗЬ + "for" + ... + ИМЯ + ... ||
                ИМЯ + "and" + ... + ИМЯ + ...
   ВОПРОСИТЕЛЬНОЕ СЛОВО -> слово из словаря вопросительных слов
   РОДСТВЕННАЯ СВЯЗЬ -> слово из словаря родственных связей
   ИМЯ -> слово из словаря имён                  
   ```
   
Обработка каждого запроса происходит через предикат `request`, который вызывает побочные предикаты: предикат `check_phrase`, который
получает список значащих слов запроса, и предикат `analyze`, который обрабатывает данный список:

```prolog
request(X, Y) :- check_phrase(X, MS), analyze(MS, Y).     
```

Реализованная программа поддерживает запросы 4 видов. Разберём каждый из них:

### How many

Данному запросу соответствует следующий переход:
```
СЕМАНТИКА -> РОДСТВЕННАЯ СВЯЗЬ + ... + ИМЯ + ...
```
То есть запрос представляет собой выражения вида "сколько таких родственников есть у этого человека?". 
При этом словарь значимых слов запроса будет иметь вид `[РОДСТВЕННАЯ СВЯЗЬ, ИМЯ]`. За выполнение запросов этого типа отвечают
следующие предикаты:

```prolog
% "how many" semantic -> relative + ... + name + ...
check_semantic_1(S, X) :-
    split(S, [P|_], [P2|_]),
    plural(P, P1),
    check_relative(P1),
    check_name(P2), !,
    append([P1], [P2], X).
    
% "how many", MS = [Relation, Name]
analyze(MS, Y) :-
    MS = [R, Name],
    check_name(Name),
    check_relative(R),
    setof(X, move(X, Name, R), L),
    length(L, Y).    
```

Примеры выполнения запроса:

```prolog
% how many cousins does Matvej Leuhin have?
?- request(['how many', 'cousins', 'does', "Matvej Leuhin", 'have', '?'], A).
A = 3 .
% How many brothers does my grandfather Nikolaj Kovalevich have?
?- request(['How many', 'brothers', 'does', 'my', 'grandfather', "Nikolaj Kovalevich", 'have', '?'], A).
A = 2 .
```

### Who is

Данному запросу соответствуют следующие переходы:

```prolog
СЕМАНТИКА -> ИМЯ + "'s" + ... + РОДСТВЕННАЯ СВЯЗЬ + ... 
СЕМАНТИКА -> РОДСТВЕННАЯ СВЯЗЬ + "for" + ... + ИМЯ + ... 
```

Такие запросы будут являться предложения вида "кто для этого человека будет таким родственником?" 
или "кто является таким родственником для этого человека?". Словарь значащих слов будет иметь вид 
`[ИМЯ, РОДСТВЕННАЯ СВЯЗЬ]`. За выполнение таких запросов отвечают следующие предикаты:

```prolog
% "who is" semantic -> name + "'s" + ... + relation + ...
check_semantic_2(S, X) :-
    split(S, [P1, "'s" |_], [P2|_]),
    check_name(P1),
    check_relative(P2), !,
    append([P1], [P2], X).

% "who is" semantic -> relation + 'for' + ... + name + ...
check_semantic_2(S, X) :-
    split(S, [P1, 'for'|_], [P2|_]),
    check_relative(P1),
    check_name(P2), !,
    append([P2], [P1], X).
    
% "who is", MS = [Name, Relation]
analyze(MS, Y) :-
    MS = [X, R],
    check_name(X),
    check_relative(R),
    move(Y, X, R).    
```

Примеры выполнения запроса:

```prolog
?- request(['Who is', "Viktor Leuhin", "'s", 'nephew', '?'], A).
A = "Anton Leuhin" ;
false.
?- request(['Who is', 'uncle', 'for', "Matvej Leuhin", '?'], A).
A = "Nikolaj Leuhin" ;
A = "Vladimir Danilushkin" ;
A = "Sergej Kovalevich" ;
false.
```

### Is

Данному запросу соответствуют следующие переходы:

```prolog
СЕМАНТИКА -> ИМЯ + ИМЯ + "'s" + ... + РОДСТВЕННАЯ СВЯЗЬ + ... 
СЕМАНТИКА -> ИМЯ + РОДСТВЕННАЯ СВЯЗЬ + "for" + ... + ИМЯ + ... 
```

Такие запросы будут являться предложения вида "этот человек является для этого человека таким родственником?"
или "этот человек является таким родственником для этого человека?". Словарь значащих слов будет иметь вид
`[ИМЯ, ИМЯ, РОДСТВЕННАЯ СВЯЗЬ]`. За выполнение таких запросов отвечают следующие предикаты:

```prolog
% "is" semantic -> name + name + "'s" + ... + relation + ...
check_semantic_3([H|T], X) :-
    check_name(H),
    split(T, [P1, "'s"|_], [P2|_]),
    check_name(P1),
    check_relative(P2), !,
    append([H], [P1], Tmp),
    append(Tmp, [P2], X).

% "is" semantic -> name + relation + "for" + ... + name + ...
check_semantic_3([H|T], X) :-
    check_name(H),
    split(T, [P1, 'for'|_], [P2|_]),
    check_relative(P1),
    check_name(P2), !,
    append([H], [P2], Tmp),
    append(Tmp, [P1], X).
    
% "is", MS = [Name, Name, Relation]
analyze(MS, _) :-
    MS = [X, Y, R],
    move(X, Y, R).

```

Примеры выполнения запроса:

```prolog
?- request(['is', "Nikolaj Kovalevich", "Matvej Leuhin", "'s", 'grandfather'], _).
true .
?- request(['is', "Valerija Leuhina", 'niece', 'for', "Matvej Leuhin"], _).
false.
?- request(['is', "Valerija Leuhina", 'cousin', 'for', "Matvej Leuhin"], _).
true .
```

### Who are

Данному запросу соответствуют следующие переходы:

```prolog
СЕМАНТИКА -> ИМЯ + "and" + ... + ИМЯ + ... 
```

Такие запросы будут являться предложения вида "кем приходятся друг другу эти люди?". 
Словарь значащих слов будет иметь вид
`[ИМЯ, ИМЯ]`. За выполнение таких запросов отвечают следующие предикаты:

```prolog
% "who are" semantic -> name + "and" + ... name + ...
check_semantic_4(S, X) :-
    split(S, [P1, 'and'|_], [P2|_]),
    check_name(P1),
    check_name(P2), !,
    append([P1], [P2], X).
    append(Tmp, [P1], X).
    
% "who are", MS = [Name, Name]
analyze(MS, Y) :-
    MS = [N1, N2],
    check_name(N1),
    check_name(N2),
    define(N1, N2, Y).
    
define(N1, N2, Y) :-
    move(N1, N2, R),
    ((R == 'mother', sex(N2, "M"), Y = "mother and son");
    (R == 'mother', sex(N2, "F"), Y = "mother and daughter");
    (R == 'father', sex(N2, "M"), Y = "father and son");
    ...
    (R == 'nephew', sex(N2, "F"), Y = "nephew and aunt");
    (R == 'niece', sex(N2, "M"), Y = "niece and uncle");
    (R == 'nephew', sex(N2, "F"), Y = "niece and aunt")).
```

Примеры выполнения запроса:

```prolog
?- request(['Who are', "Matvej Leuhin", 'and', "Sergej Kovalevich", '?'], A).
A = "nephew and uncle" ;
false .
```

## Выводы

В процессе выполнения курсовой работы я больше узнал о парадигме логического программирования.
Изначально я относился к ней довольно скептически, так как мне казалось, что она имеет слишком
мало применений. На деле же оказалось, что средствами языков логического программирования можно решать очень
широкий спектр задач, причём это решение может быть значительно проще, чем решение при помощи средств 
императивных языков программирования.

Сама курсовая работа включает в себя несколько заданий, для решения которых необходимо всесторонне подойти 
к изучению логического программирования. Например, мне очень симпатизирует метод решения определённых задач
с помощью поиска в пространстве состояний - он относительно простой, но при этом 
эффективный и вполне применимый на практике. А задание, связанное с реализацией естественно-языкового интерфейса
было для меня самым интересным, так как для его выполнения я подробнее узнал о том, что вообще такое
естественные языки и как происходит их обработка. Полученные знания я смогу применять и в будущем, при 
реализации других программ.
